<!DOCTYPE html>
<html>

<head>
  <link rel="shortcut icon" href="../public/favicon.ico" type="image/x-icon">
  <title>D3.JS Donut Chart example</title>
  <meta charset="utf-8">
  <style>
    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      width: calc(100vw - 3em);
      height: calc(100vh - 3em);
      position: relative;
      border: 1px solid #999;
      border-radius: 0.3em;
    }

    h4 {
      display: inline;
      margin: 0.3em 0 0 0.2em;
    }

    path.slice {
      stroke-width: 2px;
    }

    polyline {
      opacity: 0.3;
      stroke: #000;
      stroke-width: 2px;
      fill: none;
    }

    svg {
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <h4>D3.JS donut chart</h4>
  <!--<button id="randomizeDonutChart">Randomize</button>-->

  <script src="../libs/d3.v7.js"></script>
  <script>
    const transitionDurationsMs = 200;
    const width = parseInt(window.getComputedStyle(document.body)["width"], 10)
    // because we expect it to be <= 80% w because we place labels
    const height = Math.min(parseInt(window.getComputedStyle(document.body)["height"], 10), width * 0.8)
    const margin = 40
    const radius = Math.min(width, height) / 2 - margin;

    const svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height)
      .append("g")
      .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    const data = {
      "1.🏠": 15.5,
      "2.💰": 12.7,
      "3.🍏": 11.9,
      "4.🚩🇩🇰": 5.2,
      "5.🔬": 5.8,
      "6.📺": 0.2,
      "7.🎮": 3.4,
      "8.🌐": 10.3,
      "9.➕": 4.1
    };
    const labels = Object.keys(data).sort();

    /*
    svg.append("g").attr("class", "slices");
    svg.append("g").attr("class", "labels");
    svg.append("g").attr("class", "lines");
    */

    const color = d3.scaleOrdinal().domain(
      labels
    ).range(
      [
        //"#e15759",
        "#59a14f", // 🏠
        "#9c755f", // 💰
        "#edc949", // 🍏
        "#f28e2c", // 🚩🇩🇰
        "#ff9da7", // 🔬
        "#af7aa1", // 📺
        "#4e79a7", // 🎮
        "#76b7b2", // 🌐
        "#bab0ab66", // ➕
      ]
    );



    var pie = d3.pie()
      // sort usually accepts d3.descending, but here we can only do this, to prevent labels cramming
      .sort(null).value((d) => d[1]);
    const data_ready = pie(Object.entries(data))


    const arc = d3.arc()
      .innerRadius(radius * 0.4)
      .outerRadius(radius * 0.8);

    const outerArc = d3.arc()
      .innerRadius(radius * 0.9)
      .outerRadius(radius * 0.9);

    svg
      .selectAll('allSlices')
      .data(data_ready)
      .join('path')
      .attr('d', arc)
      .attr('fill', d => color(d.data[1]))
      .attr("stroke", "white")
      .style("stroke-width", "2px")
      .style("opacity", 0.7);

    svg
      .selectAll('allPolylines')
      .data(data_ready)
      .join('polyline')
      .attr("stroke", "black")
      .style("fill", "none")
      .attr("stroke-width", 1)
      .attr('points', (d) => {
        const posA = arc.centroid(d) // line insertion in the slice
        const posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that
        const posC = outerArc.centroid(d); // Label position = almost the same as posB
        const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left
        posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left
        return [posA, posB, posC]
      });

    svg
      .selectAll('allLabels')
      .data(data_ready)
      .join('text')
      .text(d => `${d.data[0]} ${d.data[1]}`)
      .attr('transform', function (d) {
        const pos = outerArc.centroid(d);
        const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
        pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);
        return `translate(${pos})`;
      })
      .style('text-anchor', (d) => {
        const midangle = d.startAngle + (d.endAngle - d.startAngle) / 2
        return (midangle < Math.PI ? 'start' : 'end')
      })

    /*
    var key = (d) => d.data.label;

    function randomData() {
      const labels = color.domain();
      const data = labels.map((label) => {
        return {
          label: label, value: parseInt(1000 * Math.random()) / 100
        }
      });
      return data;
    }

    change(randomData());

    d3.select("#randomizeDonutChart").on("click", () => change(randomData()));

    function change(data) {

      var slice = svg.select(".slices").selectAll("path.slice")
        .data(pie(data), key);

      slice.enter()
        .insert("path")
        .style("fill", (d) => color(d.data.label))
        .attr("class", "slice");

      slice
        .transition().duration(transitionDurationsMs)
        .attrTween("d", (d) => {
          this._current = this._current || d;
          var interpolate = d3.interpolate(this._current, d);
          this._current = interpolate(0);
          return (t) => arc(interpolate(t));
        })

      slice.exit().remove();

      svg.selectAll("text.donut-chart-labels").remove();
      var text = svg.selectAll("text.donut-chart-labels")
        .data(pie(data), key);
      text.enter()
        .append("text").attr("class", "donut-chart-labels").attr("dy", ".35em")
        .text((d) => `${d.data.label} ${d.data.value.toPrecision(3)}`);

      midAngle = (d) => d.startAngle + (d.endAngle - d.startAngle) / 2;

      text.transition().duration(transitionDurationsMs)
        .attrTween("transform", (d) => {
          this._current = this._current || d;
          var interpolate = d3.interpolate(this._current, d);
          this._current = interpolate(0);
          return (t) => {
            var d2 = interpolate(t);
            var pos = outerArc.centroid(d2);
            pos[0] = radius * (midAngle(d2) < Math.PI ? 1 : -1);
            return "translate(" + pos + ")";
          };
        })
        .styleTween("text-anchor", (d) => {
          this._current = this._current || d;
          var interpolate = d3.interpolate(this._current, d);
          this._current = interpolate(0);
          return (t) => {
            var d2 = interpolate(t);
            return midAngle(d2) < Math.PI ? "start" : "end";
          };
        });

      text.exit().remove();

      var polyline = svg.select(".lines").selectAll("polyline")
        .data(pie(data), key);

      polyline.enter().append("polyline");

      polyline.transition().duration(transitionDurationsMs)
        .attrTween("points", (d) => {
          this._current = this._current || d;
          var interpolate = d3.interpolate(this._current, d);
          this._current = interpolate(0);
          return (t) => {
            var d2 = interpolate(t);
            var pos = outerArc.centroid(d2);
            pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1 : -1);
            return [arc.centroid(d2), outerArc.centroid(d2), pos];
          };
        });

      polyline.exit().remove();

    };
    */

  </script>
</body>

</html>